{"mappings":"AAAA,MAmBMA,EAAcC,OAAOC,WAAa,IAAM,EAAID,OAAOC,WAAa,EAAID,OAAOC,WAC3EC,EAAeF,OAAOG,YAAc,GAE1C,IACIC,EADAC,EAAM,GAGVL,OAAOM,QAAO,KACZF,EAAMG,UAAS,gBAGjBP,OAAOQ,MAAK,KACVC,aAAaV,EAAaG,GAC1BQ,aAAa,GAEbC,aACAP,EAAIO,aAhBQ,kBAkBKC,MAAQC,OAGvBT,EAAIU,OAAO,EAAGD,QAEdT,EAAIU,OAAOF,MAAO,GAGpBG,MAAMX,EAAK,EAAG,GAEdY,WA9CsB,IA+CtBC,aAAa,GACbC,OA9CkB,IADA,IAgDlBC,YA5CmB,GACA,QA6Cd,IAAIC,EAAI,EAAGA,EArCQ,IAqCeA,IACrCf,EAAOe,GAAKC,aAAaT,MAAQ,EAAIU,QAAM,IArCxB,KAqCgET,OAAS,EAAIS,QArC7E,IAAA,MAsCnBjB,EAAOe,GAAGG,QAAUD,SACpBjB,EAAOe,GAAGI,UAAW,GAIzBxB,OAAOyB,KAAI,SACJ,IAAIC,EAAK,EAAGA,EAAKrB,EAAOsB,OAAQD,IAAM,CACzC,IAAIN,EAAIf,EAAOqB,GACXE,EAzDU,KAyDDR,EAAES,EACXC,EA1DU,KA0DDV,EAAEW,EACXC,EAvDc,EAuDLC,WAtDS,EAsDoBb,EAAEG,QACxCW,EAAQd,EAAES,EAAIM,IAAIC,MAAMR,EAAQE,EAAQE,GAAS,EAAG,GArD1C,EAAA,GAsDVK,EAAQjB,EAAEW,EAAII,IAAIC,MAAMR,EAAQE,EAAQE,EAAS,KAAM,EAAG,GAtDhD,EAAA,GAuDd,MAAMM,EAAWlC,EAAImC,IAAInB,EAAES,EAAGT,EAAEW,GAChCb,OAAOoB,EAAS,IAAM,EAAGA,EAAS,IAAM,EAAGA,EAAS,IAAM,GAC1DE,KAAKpB,EAAES,EAAGT,EAAEW,EAAGG,EAAOG,GACtBjB,EAAES,EAAIK,EACNd,EAAEW,EAAIM,EAEFf,SAxDgB,OAyDlBF,EAAEI,UAAW,KAGVJ,EAAEI,UAAYJ,EAAES,EAAIjB,OAASQ,EAAES,EAAI,GAAKT,EAAEW,EAAI,GAAKX,EAAEW,EAAIlB,SAC5DR,EAAOoC,OAAOf,EAAI,GAItB,MAAMgB,EAAWC,EAAS/B,MAAQ,EAAIU,QAAM,IAlEvB,KAkE+DT,OAAS,EAAIS,QAlE5E,IAAA,MAmErBjB,EAAOA,EAAOsB,QAAUe,EAEpBrC,EAAOsB,OAnEK,KAoEdtB,EAAOoC,OAAO,EAAG,IAIrBzC,OAAO4C,aAAY,SACZ,IAAIC,EAAI,EAAGA,EA7EK,EA6EeA,IAAK,CACvC,MAAMH,EAAWC,EAASG,OAAQC,QAClC1C,EAAOA,EAAOsB,QAAUe,IAI5B,MAAMC,EAAQ,CAAId,EAAGE,KACnB,IAAIiB,EAAQ1B,OAAO2B,KACfC,EAAYC,kBAAc,GAA8B,GAAM,YAE3DtB,EAAIqB,EAAYE,IAAIJ,KACpBjB,EAAImB,EAAYG,IAAIL,WACd1B,SACXE,UAAU","sources":["js/about.js"],"sourcesContent":["const backgroundColor = 35; //kinda self-explanatory\nconst strokeAlpha = 60; //the alpha of the lines (lower numbers are more transparent)\nconst strokeColor = 255; //the line color\n\nconst noiseZoom = 0.006; //how zoomed in the perlin noise is\nconst noiseOctaves = 14; //The number of octaves for the noise\nconst noiseFalloff = 0.5; //The falloff for the noise layers\n\nconst zOffsetChange = 0; //How much the noise field changes in the z direction each frame\nconst individualZOffset = 0; //how far away the points/lines are from each other in the z noise axies (the bigger the number, the more chaotic)\n\nconst lineSpeed = 5; //the maximum amount each point can move each frame\n\nconst newPointsCount = 9; //the number of new points added when the mouse is dragged\nconst numStartingPoints = 1000;\nconst startingOffset = 400;\nconst particlePersist = 0.999;\nconst maxPoints = 2000;\nconst imgAR = 2318 / 2571;\nconst canvasWidth = window.innerWidth > 600 ? 2 * window.innerWidth / 3 : window.innerWidth;\nconst canvasHeight = window.innerHeight - 85;\n\nlet points = [];\nlet img;\n\nwindow.preload = () => {\n  img = loadImage(\"aboutp1.jpg\");\n}\n\nwindow.setup = () => {\n  createCanvas(canvasWidth, canvasHeight);\n  pixelDensity(1);\n\n  loadPixels();\n  img.loadPixels();\n\n  const canvasAR = width / height;\n\n  if (imgAR > canvasAR) {\n    img.resize(0, height);\n  } else {\n    img.resize(width, 0);\n  }\n  \n  image(img, 0, 0);\n\n  background(backgroundColor);\n  strokeWeight(2);\n  stroke(strokeColor, strokeAlpha);\n  noiseDetail(noiseOctaves, noiseFalloff);\n\n  for (let p = 0; p < numStartingPoints; p++) {\n    points[p] = createVector(width / 2 + random(-startingOffset - 50, startingOffset), height / 2 + random(-startingOffset, startingOffset));\n    points[p].zOffset = random();\n    points[p].isMoving = true;\n  }\n}\n\nwindow.draw = () => {\n  for (let pt = 0; pt < points.length; pt++) {\n    let p = points[pt];\n    let noiseX = p.x * noiseZoom;\n    let noiseY = p.y * noiseZoom;\n    let noiseZ = frameCount * zOffsetChange + p.zOffset * individualZOffset;\n    let newPX = p.x + map(noise(noiseX, noiseY, noiseZ), 0, 1, -lineSpeed, lineSpeed);\n    let newPY = p.y + map(noise(noiseX, noiseY, noiseZ + 214), 0, 1, -lineSpeed, lineSpeed);\n    const pixColor = img.get(p.x, p.y);\n    stroke(pixColor[0] || 0, pixColor[1] || 0, pixColor[2] || 0);\n    line(p.x, p.y, newPX, newPY);\n    p.x = newPX;\n    p.y = newPY;\n\n    if (random() > particlePersist) {\n      p.isMoving = false;\n    }\n\n    if (!p.isMoving || p.x > width || p.x < 0 || p.y < 0 || p.y > height) {\n      points.splice(pt, 1);\n    }\n  }\n\n  const newPoint = getPoint(width / 2 + random(-startingOffset - 50, startingOffset), height / 2 + random(-startingOffset, startingOffset));\n  points[points.length] = newPoint;\n\n  if (points.length > maxPoints) {\n    points.splice(0, 1);\n  }\n}\n\nwindow.mouseDragged = () => {\n  for (let i = 0; i < newPointsCount; i++) {\n    const newPoint = getPoint(mouseX, mouseY);\n    points[points.length] = newPoint;\n  }\n}\n\nconst getPoint = (x, y) => {\n  let angle = random(TAU);\n  let magnitude = randomGaussian() * ((newPointsCount - 1) ** 0.5 * 3);\n  return {\n    \"x\": x + magnitude * cos(angle),\n    \"y\": y + magnitude * sin(angle),\n    \"zOffset\": random(),\n    isMoving: true\n  };\n}"],"names":["$b646c2cb81d84733$var$canvasWidth","window","innerWidth","$b646c2cb81d84733$var$canvasHeight","innerHeight","$b646c2cb81d84733$var$img","$b646c2cb81d84733$var$points","preload","loadImage","setup","createCanvas","pixelDensity","loadPixels","width","height","resize","image","background","strokeWeight","stroke","noiseDetail","p","createVector","random","zOffset","isMoving","draw","pt","length","noiseX","x","noiseY","y","noiseZ","frameCount","newPX","map","noise","newPY","pixColor","get","line","splice","newPoint","$b646c2cb81d84733$var$getPoint","mouseDragged","i","mouseX","mouseY","angle","TAU","magnitude","randomGaussian","cos","sin"],"version":3,"file":"about.70b07a3d.js.map"}