{"mappings":"AAAA,MAkBMA,EAAcC,OAAOC,WAAa,IAAM,EAAID,OAAOC,WAAa,EAAID,OAAOC,WAC3EC,EAAeF,OAAOG,YAAc,GAE1C,IACIC,EADAC,EAAM,GAGVL,OAAOM,QAAO,KACZF,EAAMG,UAAS,8FAGjBP,OAAOQ,MAAK,KACVC,aAAaV,EAAaG,GAC1BQ,aAAa,GAEbC,aACAP,EAAIO,aACJP,EAAIQ,OAAO,EAAGC,QAEdC,MAAMV,EAAK,EAAG,GAEdW,WAtCsB,IAuCtBC,aAAa,GACbC,OAtCkB,IADA,IAwClBC,YApCmB,GACA,QAqCd,IAAIC,EAAI,EAAGA,EA7BQ,IA6BeA,IACrCd,EAAOc,GAAKC,aAAaC,MAAQ,EAAIC,QAAM,IA7BxB,KA6BgET,OAAS,EAAIS,QA7B7E,IAAA,MA8BnBjB,EAAOc,GAAGI,QAAUD,SACpBjB,EAAOc,GAAGK,UAAW,GAIzBxB,OAAOyB,KAAI,SACJ,IAAIC,EAAK,EAAGA,EAAKrB,EAAOsB,OAAQD,IAAM,CACzC,IAAIP,EAAId,EAAOqB,GACXE,EAjDU,KAiDDT,EAAEU,EACXC,EAlDU,KAkDDX,EAAEY,EACXC,EA/Cc,EA+CLC,WA9CS,EA8CoBd,EAAEI,QACxCW,EAAQf,EAAEU,EAAIM,IAAIC,MAAMR,EAAQE,EAAQE,GAAS,EAAG,GA7C1C,EAAA,GA8CVK,EAAQlB,EAAEY,EAAII,IAAIC,MAAMR,EAAQE,EAAQE,EAAS,KAAM,EAAG,GA9ChD,EAAA,GA+Cd,MAAMM,EAAWlC,EAAImC,IAAIpB,EAAEU,EAAGV,EAAEY,IAE5BT,SA5CgB,MA4C8B,IAAhBgB,EAAS,MACzCnB,EAAEK,UAAW,IAGVL,EAAEK,UAAYL,EAAEU,EAAIR,OAASF,EAAEU,EAAI,GAAKV,EAAEY,EAAI,GAAKZ,EAAEY,EAAIlB,OAC5DR,EAAOmC,OAAOd,EAAI,IAElBT,OAAOqB,EAAS,IAAM,EAAGA,EAAS,IAAM,EAAGA,EAAS,IAAM,GAC1DG,KAAKtB,EAAEU,EAAGV,EAAEY,EAAGG,EAAOG,GACtBlB,EAAEU,EAAIK,EACNf,EAAEY,EAAIM,GAIV,MAAMK,EAAWC,EAAStB,MAAQ,EAAIC,QAAM,IA3DvB,KA2D+DT,OAAS,EAAIS,QA3D5E,IAAA,MA4DrBjB,EAAOA,EAAOsB,QAAUe,EAEpBrC,EAAOsB,OA5DK,KA6DdtB,EAAOmC,OAAO,EAAG,IAIrBxC,OAAO4C,WAAU,SACV,IAAIC,EAAI,EAAGA,EAtEK,EAsEeA,IAAK,CACvC,MAAMH,EAAWC,EAASG,OAAQC,QAClC1C,EAAOA,EAAOsB,QAAUe,IAI5B,MAAMC,EAAQ,CAAId,EAAGE,KACnB,IAAIiB,EAAQ1B,OAAO2B,KACfC,EAA0B,EAAdC,0BAETtB,EAAIqB,EAAYE,IAAIJ,KACpBjB,EAAImB,EAAYG,IAAIL,WACd1B,SACXE,UAAU","sources":["js/about.js"],"sourcesContent":["const backgroundColor = 35; //kinda self-explanatory\nconst strokeAlpha = 60; //the alpha of the lines (lower numbers are more transparent)\nconst strokeColor = 255; //the line color\n\nconst noiseZoom = 0.006; //how zoomed in the perlin noise is\nconst noiseOctaves = 14; //The number of octaves for the noise\nconst noiseFalloff = 0.5; //The falloff for the noise layers\n\nconst zOffsetChange = 0; //How much the noise field changes in the z direction each frame\nconst individualZOffset = 0; //how far away the points/lines are from each other in the z noise axies (the bigger the number, the more chaotic)\n\nconst lineSpeed = 5; //the maximum amount each point can move each frame\n\nconst newPointsCount = 2; //the number of new points added when the mouse is dragged\nconst numStartingPoints = 1000;\nconst startingOffset = 400;\nconst particlePersist = 0.999;\nconst maxPoints = 2000;\nconst canvasWidth = window.innerWidth > 600 ? 2 * window.innerWidth / 3 : window.innerWidth;\nconst canvasHeight = window.innerHeight - 85;\n\nlet points = [];\nlet img;\n\nwindow.preload = () => {\n  img = loadImage(\"https://res.cloudinary.com/iireii/image/upload/v1633834635/Portfolio/portrait2_navdqe.jpg\");\n}\n\nwindow.setup = () => {\n  createCanvas(canvasWidth, canvasHeight);\n  pixelDensity(1);\n\n  loadPixels();\n  img.loadPixels();\n  img.resize(0, height);\n  \n  image(img, 0, 0);\n\n  background(backgroundColor);\n  strokeWeight(2);\n  stroke(strokeColor, strokeAlpha);\n  noiseDetail(noiseOctaves, noiseFalloff);\n\n  for (let p = 0; p < numStartingPoints; p++) {\n    points[p] = createVector(width / 2 + random(-startingOffset - 50, startingOffset), height / 2 + random(-startingOffset, startingOffset));\n    points[p].zOffset = random();\n    points[p].isMoving = true;\n  }\n}\n\nwindow.draw = () => {\n  for (let pt = 0; pt < points.length; pt++) {\n    let p = points[pt];\n    let noiseX = p.x * noiseZoom;\n    let noiseY = p.y * noiseZoom;\n    let noiseZ = frameCount * zOffsetChange + p.zOffset * individualZOffset;\n    let newPX = p.x + map(noise(noiseX, noiseY, noiseZ), 0, 1, -lineSpeed, lineSpeed);\n    let newPY = p.y + map(noise(noiseX, noiseY, noiseZ + 214), 0, 1, -lineSpeed, lineSpeed);\n    const pixColor = img.get(p.x, p.y);\n\n    if (random() > particlePersist || pixColor[3] === 0) {\n      p.isMoving = false;\n    }\n\n    if (!p.isMoving || p.x > width || p.x < 0 || p.y < 0 || p.y > height) {\n      points.splice(pt, 1);\n    } else {\n      stroke(pixColor[0] || 0, pixColor[1] || 0, pixColor[2] || 0);\n      line(p.x, p.y, newPX, newPY);\n      p.x = newPX;\n      p.y = newPY;\n    }\n  }\n\n  const newPoint = getPoint(width / 2 + random(-startingOffset - 50, startingOffset), height / 2 + random(-startingOffset, startingOffset));\n  points[points.length] = newPoint;\n\n  if (points.length > maxPoints) {\n    points.splice(0, 1);\n  }\n}\n\nwindow.mouseMoved = () => {\n  for (let i = 0; i < newPointsCount; i++) {\n    const newPoint = getPoint(mouseX, mouseY);\n    points[points.length] = newPoint;\n  }\n}\n\nconst getPoint = (x, y) => {\n  let angle = random(TAU);\n  let magnitude = randomGaussian() * ((newPointsCount - 1) ** 0.5 * 3);\n  return {\n    \"x\": x + magnitude * cos(angle),\n    \"y\": y + magnitude * sin(angle),\n    \"zOffset\": random(),\n    isMoving: true\n  };\n}"],"names":["$b646c2cb81d84733$var$canvasWidth","window","innerWidth","$b646c2cb81d84733$var$canvasHeight","innerHeight","$b646c2cb81d84733$var$img","$b646c2cb81d84733$var$points","preload","loadImage","setup","createCanvas","pixelDensity","loadPixels","resize","height","image","background","strokeWeight","stroke","noiseDetail","p","createVector","width","random","zOffset","isMoving","draw","pt","length","noiseX","x","noiseY","y","noiseZ","frameCount","newPX","map","noise","newPY","pixColor","get","splice","line","newPoint","$b646c2cb81d84733$var$getPoint","mouseMoved","i","mouseX","mouseY","angle","TAU","magnitude","randomGaussian","cos","sin"],"version":3,"file":"about.4b775b16.js.map"}